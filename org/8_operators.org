#+TITLE: OPERATORS
#+AUTHOR:Marcus Birkenkrahe
#+SUBTITLE:CSC100 Introduction to programming in C/C++ (Spring 2024)
#+STARTUP: overview hideblocks indent inlineimages
#+SEQ_TODO: PRACTICE NEXT | DONE
#+OPTIONS: toc:1 ^:nil
#+PROPERTY: header-args:C :main yes :includes <stdio.h> :exports both :results output :noweb yes :tangle yes
#+property: header-args:R :session *R* :results output :exports both :noweb yes:
* README
#+attr_latex: :width 400px
#+caption: City, telephone room, 1955 (Flickr.com)
[[../img/8_operators.jpg]]

- In this section of the course, we go beyond simple statements and
  turn to program flow and evaluation of logical conditions

- This section follows chapter 3 in the book by Davenport/Vine (2015)
  and chapters 4 and 5 in the book by King (2008)

- Practice workbooks, input files and PDF solution files in GitHub

* Preamble
#+attr_latex: :width 400px
#+caption: Photo: Alan Levine, public domain. Source: Flickr.com
[[../img/8_stop.jpg]]

- *Algorithms* are the core of programming

- Example for an algorithm: /"When you come to a STOP sign, stop."/

- The human form of algorithm is *heuristics*

- Example for a heuristic: /"To get to the college, go straight."/

- For *programming*, you need both algorithms and heuristics

- Useful tools to master when designing algorithms:
  - *Pseudocode* (task flow description)
  - *Visual modeling* (task flow visualization)

* Operators in C

- Mathematically, operators are really functions: ~f(i,j)=i+j~

- C has many operators, both *unary*, with one argument, like =-1=, and
  *binary*, with two arguments, like =1+1=.

- A list of types of operators in C:

  #+caption: Operator types in C
  | OPERATOR            | WHY USE IT            | EXAMPLES  | EXPRESSION |
  |---------------------+-----------------------+-----------+------------|
  | Arithmetic          | compute               | * + - / % | i * j + k  |
  | Relational          | compare               | < > <= >= | i > j      |
  | Equality            | compare (in/equality) | ~==~ ~!=~     | i ~==~ j     |
  | Logical             | confirm (truth)       | ~&&~        | i ~&&~ j     |
  | Assignment          | change                | =         | i ~=~ j      |
  | Increment/decrement | change stepwise       | ~++~, ~+-~    | ~++i~        |

- Note: there is no exponential operator (though there is a power
  function =pow= in =math.h= [fn:1] - you need to use ~*~ instead.

- *Conditional* operators used in C are important for program flow:
  #+caption: Conditional operators in C
  | OPERATOR | DESCRIPTION              | EXPRESSION | BOOLEAN VALUE |
  |----------+--------------------------+------------+---------------|
  | ==       | Equal                    | 5 == 5     | true          |
  | !=       | Not equal                | 5 != 5     | false         |
  | >        | Greater than             | 5 > 5      | false         |
  | <        | Less than                | 5 < 5      | false         |
  | >=       | Greater than or equal to | 5 >= 5     | true          |
  | <=       | Less than or equal to    | 5 <= 5     | true          |

- Conditional = the operator tests a condition:
  #+begin_example C
  x == y // is x equal to y? if yes, then return TRUE
  #+end_example

- The value of an evaluated conditional operator is *Boolean*
  (logical) - e.g. ~2==2~ evaluates as ~TRUE~ or ~1~.

- The only *unary* operator is ~!~ also known as NOT: It merely inverts
  the Boolean or truth value of its argument.
  #+begin_src C
    int x = 1;  // defining x
    printf("If x = %d, then: NOT x = %d\n",x, !x);
    printf("If x = !%d, then: x = %d\n",!x, x);
  #+end_src

  #+RESULTS:
  : If x = 1, then: NOT x = 0
  : If x = !0, then: x = 1

* Operators in other languages
#+attr_latex: :width 400px
#+caption: Photo: Jack Delano, Sawmill (1939). Source: Library of Congress
[[../img/8_pipeline.jpg]]

- Different programming languages differ greatly rgd. operators. For
  example, in the language R, the ~|>~ operator ("pipe") passes a data
  set to a function[fn:2].

  #+begin_src R :results output
    ## pipe data set into function
    mtcars |> head(n=2)
    ## use data set as function argument
    head(mtcars,n=2)
  #+end_src

  #+RESULTS:
  :               mpg cyl disp  hp drat    wt  qsec vs am gear carb
  : Mazda RX4      21   6  160 110  3.9 2.620 16.46  0  1    4    4
  : Mazda RX4 Wag  21   6  160 110  3.9 2.875 17.02  0  1    4    4
  :               mpg cyl disp  hp drat    wt  qsec vs am gear carb
  : Mazda RX4      21   6  160 110  3.9 2.620 16.46  0  1    4    4
  : Mazda RX4 Wag  21   6  160 110  3.9 2.875 17.02  0  1    4    4

- You already met the ~>~ and ~>>~ operators of the ~bash~ shell language
  that redirects standard output to a file:

  #+begin_src bash
    > empty  # create empty file called "empty"
    ls -l empty  # shows the result
  #+end_src

  #+RESULTS:
  : -rw-rw-r-- 1 marcus marcus 0 Feb 24 09:35 empty

  #+begin_src bash :results output
    echo 100 > input
    cat input
  #+end_src

  #+RESULTS:
  : 100

* PRACTICE Build a simple calculator

- Execute this exercise using the Google Cloud Shell, the ~nano~ editor,
  and the ~gcc~ compiler. Put your result in a file ~calc.c~

- Write a simple calculator for integer values.

- ~#include <stdio.h>~ and use the following pseudocode inside ~main~:
  #+begin_example
  // declare two integer variables a, b

  // ask user for input

  // get two integer values as input (from the keyboard)

  // compute and print results for +, -, *, /, %

  #+end_example
- You can also first declare & define two static values (i=125, j=5),
  test the calculator, and then add the =scanf= statement for keyboard
  input.

- Sample input: 125 5

- Sample output:
  #+begin_example
  : Enter two numbers: 125 5
  : 125 + 5 = 130
  : 125 - 5 = 120
  : 125 * 5 = 625
  : 125 / 5 = 25
  : 125 % 5 = 0
  #+end_example

** Solution:

Input:
#+begin_src bash :results output :exports both
  echo "125 5" > input
  cat input
#+end_src

#+RESULTS:
: 125 5

#+begin_src C :main no :includes :cmdline <input
  #include <stdio.h>

  int main() {
    int a, b;
    printf("Enter two numbers: ");
    scanf("%d%d", &a, &b);
    printf("%d %d\n",a,b);

    printf("%d + %d = %d\n", a, b, a + b);
    printf("%d - %d = %d\n", a, b, a - b);
    printf("%d * %d = %d\n", a, b, a * b);
    printf("%d / %d = %d\n", a, b, a / b);
    printf("%d %% %d = %d\n", a, b, a % b);

    return 0;
  }
#+end_src

* Boolean algebra

- What is algebra about?[fn:3]

- Why algebra? Algebra allows you to form small worlds with fixed laws
  so that you know exactly what's going on - what the output must be
  for a given input. This certainty is what is responsible for much of
  the magic of mathematics.

- Boole's (or Boolean) algebra, or the algebra of *logic*, uses the
  values of =TRUE= (or =1=) and =FALSE= (or =0=) and the operators =AND= (or
  "conjunction"), =OR= (or "disjunction"), and =NOT= (or "negation").

- *Truth tables* are one way of showing Boolean relationships (there are
  many other ways, some more intuitive than others[fn:4]):

  #+name: AND
  #+caption: Conjunction: `p AND q` for all values of p,q
  | p     | q     | p AND q   |
  |-------+-------+-----------|
  | TRUE  | TRUE  | TRUE      |
  | TRUE  | FALSE | FALSE     |
  | FALSE | TRUE  | FALSE     |
  | FALSE | FALSE | FALSE     |

  #+name: OR
  #+caption: Disjunction: `p OR q` for all values of p,q
  | p     | q     | p OR q |
  |-------+-------+--------|
  | TRUE  | TRUE  | TRUE   |
  | TRUE  | FALSE | TRUE   |
  | FALSE | TRUE  | TRUE   |
  | FALSE | FALSE | FALSE  |

  #+name: NOT
  #+caption: Inverse: `p` and `NOT p` for all values of p
  | p     | NOT p    |
  |-------+----------|
  | TRUE  | FALSE    |
  | FALSE | TRUE     |

* Exploring Boolean algebra

Let's explore Boolean algebra in three different ways to help
absolutely everyone get a picture of what it means.

** Conjunction: Logic gates (digital circuits)

- Go to CircuitVerse (circuitverse.org) and sign up for free with your
  Google Mail account.

- Create a logic gate that represents the operation =p AND q= for
  varying values of =p= and =q=:

  1) Select two *input* values.

  2) Select the "Logical conjunction" gate ("D").

  3) Select an *output* value.

  4) Combine the elements.

  5) Run through the truth values of the table.

  6) If you want to keep it, save it as a project.

- Your logic gate should look like this:
  #+attr_html: :width 400px:
  #+caption: Source: CircuitVerse project
  [[../img/circuit.png]]

  [[https://circuitverse.org/users/295893/projects/p-and-q-5c957f45-27a3-46f9-99b0-c1cc43719ccb][(Project link)]]

** Disjunction: Set theory (vector algebra)

- Set up the sets in an R language code block
  #+begin_src R :results output
    p <- c(TRUE, TRUE, FALSE, FALSE) # set of p values
    q <- c(TRUE, FALSE, TRUE, FALSE) # set of q values
    tt <- data.frame("p"=p,"q"=q)    # truth table setup
    print(tt,row.names=FALSE)
  #+end_src

  #+RESULTS:
  :      p     q
  :   TRUE  TRUE
  :   TRUE FALSE
  :  FALSE  TRUE
  :  FALSE FALSE

- Compute the
#+begin_src R
  tt["p OR q"] <- p | q # check p OR q for every row of the table
  print(tt,row.names=FALSE)
#+end_src

#+RESULTS:
:      p     q p OR q
:   TRUE  TRUE   TRUE
:   TRUE FALSE   TRUE
:  FALSE  TRUE   TRUE
:  FALSE FALSE  FALSE

** Inverse: Set theory diagram (Euler diagram)

- The box is the universe.
  #+begin_quote
  =p= is represented by a circle inside the box.
  #+end_quote
  #+attr_html: :width 400px:
  #+caption: Euler diagram: p in the universe
  [[../img/p.png]]

- What is =NOT p= (=\not p=)?
  #+begin_quote
  =NOT p= is the universe outside of =p=.
  #+end_quote
  #+attr_html: :width 400px:
  #+caption: Euler diagram: p and NOT p in the universe
  [[../img/not_p.png]]

- Therefore, what is the Boolean equation for the universe?
  #+begin_quote
  The universe is =p AND (NOT P).=
  #+end_quote
  #+attr_html: :width 400px:
  #+caption: Euler diagram: p AND (NOT p) = Universe
  [[../img/universe.png]]

* PRACTICE Boolean logic test

- Go to Google Cloud shell (ide.cloud.google.com) and run the
  following command on the shell (~-O~ is a big-Oh, not a zero):
  #+begin_example
  wget -O boolean.c tinyurl.com/predict-boolean
  #+end_example

- Open the file ~boolean.c~ in the ~nano~ editor.

- Write the answer you expect in the place of the XX characters. Then
  compile and run the program to see if you were right or wrong.

- Code template (this will NOT compile!):
  #+begin_src C :tangle ../src/boolean-template.c
    #include <stdio.h>

    int main() {
      int x = 1, y = 0, z = 5;

      // Below, replace `?` by what you expect the Boolean expression
      // result in - for example for the first statement, compute (in
      // your head) `1 && 0` (which is 1 AND 0 in the truth table, and
      // replace `?` by what you think the result will be.
      // EXAMPLE: x && x = 1 && 1 = TRUE = 1
      // printf("%d == %d\n", x && y, 1);

      printf("%d == %d\n", x && y, ?);
      printf("%d == %d\n", x || y, ?);
      printf("%d == %d\n", x == y, ?);
      printf("%d == %d\n", !x, ?);
      printf("%d == %d\n", z > x && y < z, ?);

      return 0;
    }
  #+end_src

** Solution:
#+begin_src C :main no :includes :tangle ../src/boolean_solution.c
  #include <stdio.h>

  int main() {
    int x = 1, y = 0, z = 5;

    // Below, replace `?` by what you expect the Boolean expression
    // result in - for example for the first statement, compute (in
    // your head) `1 && 0` (which is 1 AND 0 in the truth table, and
    // replace `?` by what you think the result will be.
    // EXAMPLE: x && x = 1 && 1 = TRUE = 1
    // printf("%d == %d\n", x && y, 1);

    printf("%d == %d\n", x && y, 0);
    printf("%d == %d\n", x || y, 1);
    printf("%d == %d\n", x == y, 0);
    printf("%d == %d\n", !x, 0);
    printf("%d == %d\n", z > x && y < z, 1);

    return 0;
  }
#+end_src

#+RESULTS:
: 0 == 0
: 1 == 1
: 0 == 0
: 0 == 0
: 1 == 1

* Expanding Boolean algebra

- Using the three basic operators, other operators can be built. In
  electronics, and modeling, the "exclusive OR" operator or "XOR",
  is e.g. equivalent to ~(p AND NOT q) OR (NOT p AND q)~.

  #+name: XOR
  #+caption: Exclusive OR: `p XOR q` and its derivation
  | p     | q     | p XOR q | P = p AND (NOT q) | Q = (NOT p) AND q | P OR Q |
  |-------+-------+---------+-------------------+-------------------+--------|
  | TRUE  | TRUE  | FALSE   | FALSE             | FALSE             | FALSE  |
  | TRUE  | FALSE | TRUE    | TRUE              | FALSE             | TRUE   |
  | FALSE | TRUE  | TRUE    | FALSE             | TRUE              | TRUE   |
  | FALSE | FALSE | FALSE   | FALSE             | FALSE             | FALSE  |

- XOR is the operator that I've used in BPMN models for
  pseudocode as a gateway operator - only one of its outcomes can be
  true but never both of them:
  #+attr_html: :width 700px:
  [[../img/problem_solving.svg]]

- How could you show the truth of the equivalence of ~p XOR q~ and ~(p
  AND NOT q) OR (NOT p AND q)~?

  #+begin_quote
  You can show this computationally by going through all p,q \in {0,1} -
  we're using a =for= loop here but we could also do it manually with
  values ~p0=0~, ~q0=0~, ~p1=0~, ~q1=1~ or as array values.
  #+end_quote

- In R (vectorized Boolean operations):
  #+begin_src R :session *R* :results output :exports both
    ## set up truth table with values for p and q
    p <- c(TRUE,TRUE,FALSE,FALSE)
    q <- c(TRUE,FALSE,TRUE,FALSE)

    tt <- data.frame(p,q)

    ## compute (p AND NOT q) OR (NOT p AND q) and add it to the table
    tt["p XOR q"] <- (p & !q) | (!p & q)

    ## print resulting truth table
    print(tt,row.names=FALSE)
  #+end_src

  #+RESULTS:
  :      p     q p XOR q
  :   TRUE  TRUE   FALSE
  :   TRUE FALSE    TRUE
  :  FALSE  TRUE    TRUE
  :  FALSE FALSE   FALSE

- In C, ~TRUE~ is ~1~ and ~FALSE~ is ~0~ (we're going to analyze this later):
  #+begin_src C :main yes :includes <stdio.h> :results output :exports both :comments both :tangle yes :noweb yes
    // non-loop approach without arrays
    int p0=0,q0=0,p1=0,q1=1,p2=1,q2=0,p3=1,q3=1;
    printf("\n%d %d %d %d\n",
           (p0 && !q0) || (!p0 && q0),
           (p1 && !q1) || (!p1 && q1),
           (p2 && !q2) || (!p2 && q2),
           (p3 && !q3) || (!p3 && q3));

    // print p XOR q - the answer should be 0 1 1 0
    for (int i=0;i<2;++i) { // 00 01 10 11
      for (int j=0;j<2;++j) {
        printf("%d ", (i && !j) || (!i && j)); //
      }
     }

    // declare truth values p,q as array
    int a[] = {0,1};
    printf("\n%d %d %d %d\n",
           (a[0] && !a[0]) || (!a[0] && a[0]),
           (a[0] && !a[1]) || (!a[0] && a[1]),
           (a[1] && !a[0]) || (!a[1] && a[0]),
           (a[1] && !a[1]) || (!a[1] && a[1]));
  #+end_src

  #+RESULTS:
  : 0 1 1 0
  : 0 1 1 0
  : 0 1 1 0

- Result:
  #+begin_quote
  Each row shows the results of ~(p AND NOT q) OR (NOT p AND q)~ from
  left to right for all values of =p= and =q=: the same as =p XOR q=:
  #+end_quote
  #+caption: `p XOR q` with Boolean values and in C (with 0,1)
  | p     | q     | p XOR q | ~printf~ |
  |-------+-------+---------+--------|
  | TRUE  | TRUE  | FALSE   |      0 |
  | TRUE  | FALSE | TRUE    |      1 |
  | FALSE | TRUE  | TRUE    |      1 |
  | FALSE | FALSE | FALSE   |      0 |

- Algebraic operations are way more elegant and insightful than truth
  tables. Watch "[[https://youtu.be/iPbLzl2kMHA?si=YkyZsUhDWTNiayuT][Proving Logical Equivalences without Truth Tables]]"
  (2012) as an example.

* Order of operator operations (codealong)

- In compound operations (multiple operators), you need to know the
  order of operator precedence.

- C has almost 50 operators - more than keywords. The most unusual are
  compound increment/decrement operators[fn:5]:

  #+caption: Compound prefix and postfix operators in C
  | STATEMENT  | COMPOUND | PREFIX | POSTFIX |
  |------------+----------+--------+---------|
  | i = i + 1; | i += 1;  | ++i;   | i++;    |
  | j = j - 1; | j -= 1;  | --i;   | i--;    |

- ~++~ and ~--~ have side effects: they modify the values of their
  operands: the /prefix/ operator ~++i~ increments ~i+1~ and then fetches
  the value ~i~:

  #+name: prefix
  #+begin_src C :results output :exports both
    int i = 1;
    printf("i is %d\n", ++i);  // increments i, then prints "i is 2"
    printf("i is %d\n", i);  // prints "i is 2"
  #+end_src

- The /postfix/ operator ~j++~ also means ~j = j + 1~ but here, the value of
  ~j~ is fetched, and then incremented.

  #+name: postfix
  #+begin_src C :results output :exports both
    int j = 1;
    printf("j is %d\n", j++);  // prints "j is 1" then increments
    printf("j is %d\n", j);  // prints "j is 2"
  #+end_src

- Here is another illustration with an assignment of post and prefix
  increment operators:

  #+name: postfixprefix
  #+begin_src C :exports both :results output
    int num1 = 10, num2 = 0;
    puts("start: num1 = 10, num2 =0");

    num2 = num1++; // assign num1 to num2 and then add 1 to num1
    printf("postfix: num2 = num1++, so num2 = %d, num1 = %d\n", num2, num1);

    num1 = 10;     // reset num1 to 10
    num2 = ++num1; // add 1 to num1 and then assign it to num2
    printf("prefix:  num2 = ++num1, so num2 = %d, num1 = %d\n", num2, num1);
  #+end_src

  #+RESULTS: postfixprefix
  : start: num1 = 10, num2 =0
  : postfix: num2 = num1++, so num2 = 10, num1 = 11
  : prefix:  num2 = ++num1, so num2 = 11, num1 = 11

- The table below shows a partial list of operators and their order of
  precedence from 1 (highest precedence, i.e. evaluated first) to 5
  (lowest precedence, i.e. evaluated last)
  #+name: order
  #+caption: Order of precedence of arithmetic operators in C
  | ORDER | OPERATOR            | SYMBOL           | ASSOCIATIVITY |
  |-------+---------------------+------------------+---------------|
  |     1 | increment (postfix) | ~++~               | left          |
  |       | decrement (postfix) | ~--~               |               |
  |-------+---------------------+------------------+---------------|
  |     2 | increment (prefix)  | ~++~               | right         |
  |       | decrement (prefix)  | ~--~               |               |
  |       | unary plus          | ~+~                |               |
  |       | unary minus         | ~-~                |               |
  |-------+---------------------+------------------+---------------|
  |     3 | multiplicative      | ~* / %~            | left          |
  |-------+---------------------+------------------+---------------|
  |     4 | additive            | ~+ -~              | left          |
  |-------+---------------------+------------------+---------------|
  |     5 | assignment          | ~= *= /= %= += -=~ | right         |

- Left/right /associativity/ means that the operator groups from
  left/right. Examples:
  #+name: associativity
  #+caption: Associativity of operators in C
  | EXPRESSION | EQUIVALENCE | ASSOCIATIVITY |
  |------------+-------------+---------------|
  | i - j - k  | (i - j) - k | left          |
  | i * j / k  | (i * j) / k | left          |
  | -+j        | - (+j)      | right         |
  | i %=j      | i = (i % j) | right         |
  | i +=j      | i = (j + 1) | right         |

- Write some of these out yourself and run examples. I found ~%=~ quite
  challenging: a modulus and assignment operator. ~i %= j~ computes ~i%j~
  (i modulus j) and assigns it to ~i~.

- What is the value of ~i = 10~ after running the code below?

  #+name: %=
  #+begin_src C :exports both
    int i = 10, j = 5;
    i %= j; // compute modulus of i and j and assigns it to i
    printf("i was 10 and is now %d = 10 %% 5\n", i);
  #+end_src

* PRACTICE Predict the output

- Go to Google Cloud shell (ide.cloud.google.com) and run the
  following command on the shell (~-O~ is a big-Oh, not a zero):
  #+begin_example
  wget -O predict.c tinyurl.com/predict-output
  #+end_example

- Open the file ~predict.c~ in the ~nano~ editor.

- Write the answer you expect in the place of the XX characters. Then
  compile and run the program to see if you were right or wrong.

- Code template:
  #+begin_example C
    #include <stdio.h>

    int main() {
      int a = 5, b = 10, c;

  // USING THE VALUES FOR a AND b, COMPUTE c IN YOUR HEAD
  // THEN ENTER THE VALUE INSTEAD OF THE QUESTION MARK ?
  // THEN COMPILE AND RUN TO SEE IF YOU GUESSED RIGHT.
  // EXAMPLE: c = b * a = 10 * 5:
  // printf("1. c = %d == %d\n", c, 50);

      c = a + b * 2;
      printf("1. c = %d == %d\n", c, ?); // what is c?

      c = (a + b) * 2;
      printf("2. c = %d == %d\n", c, ?);

      c = b / a + 3;
      printf("3. c = %d == %d\n", c, ?);

      c = ++a + b--;
      printf("4. a = %d == %d, b = %d == %d, c = %d == %d\n",
             a, ?, b, ?, c, ?);

      return 0;
    }
  #+end_example

** Solution:
#+begin_src C :main no :includes :tangle ../src/predict_solution.c
  #include <stdio.h>

  int main() {
    int a = 5, b = 10, c;

    // USING THE VALUES FOR a AND b, COMPUTE c IN YOUR HEAD
    // THEN ENTER THE VALUE INSTEAD OF THE QUESTION MARK ?
    // THEN COMPILE AND RUN TO SEE IF YOU GUESSED RIGHT.
    // EXAMPLE: c = b * a = 10 * 5:
    // printf("1. c = %d == %d\n", c, 50);

    c = a + b * 2;
    printf("1. c = %d == %d\n", c, 25); // replace XX by your guess

    c = (a + b) * 2;
    printf("2. c = %d == %d\n", c, 30);

    c = b / a + 3;
    printf("3. c = %d == %d\n", c, 5);

    c = ++a + b--;
    printf("4. a = %d == %d, b = %d == %d, c = %d == %d\n",
           a, 6, b, 9, c, 16);

    return 0;
  }
#+end_src

#+RESULTS:
: 1. c = 25 == 25
: 2. c = 30 == 30
: 3. c = 5 == 5
: 4. a = 6 == 6, b = 9 == 9, c = 16 == 16
* Booleans in C

- C evaluates all non-zero values as ~TRUE~ (~1~), and all zero values as
  ~FALSE~ (~0~):

  #+name: boolean
  #+begin_src C :results output :exports both
    if (3) {
      puts("3 is TRUE"); // non-zero expression
     }
    if (!0) puts("0 is FALSE"); // !0 is literally non-zero
  #+end_src

- The Boolean operators AND, OR and NOT are represented in C by
  the logical operators ~&&~, ~||~ and ~!~, respectively.

* ! operator (logical NOT)

- The ! operator is a "unary" operator that is evaluated from the
  left. It is ~TRUE~ when its argument is ~FALSE~ (~0~), and it is ~FALSE~
  when its argument is ~TRUE~ (non-zero).

- If ~i = 100~, what is ~!i~?
  #+begin_quote
  The Boolean value of ~100~ is TRUE. Therefore, ~!100~ = ~!TRUE~ = ~FALSE~.
  #+end_quote

- If ~j = 1.0e-15~, what is ~!j~?
  #+begin_quote
  The Boolean value of ~1.0e-15~ is TRUE. Therefore, ~!1.0e-15~ = ~!TRUE~ =
  ~FALSE~.
  #+end_quote

- Let's check! You can validate these arguments computationally:
  #+name: negation
  #+begin_src C :results output :exports both
    // declare and assign variables
    int i = 100;
    double j = 1.e-15;
    // print output
    printf("!%d is %d because %d is non-zero!\n", i, !i, i);
    printf("!(%.1e) is %d because %.1e is non-zero!\n", j, !j, j);
  #+end_src

  #+RESULTS: negation
  : !100 is 0 because 100 is non-zero!
  : !(1.0e-15) is 0 because 1.0e-15 is non-zero!

* && operator (logical AND)

- Evaluates a Boolean expression from left to right

- Its value is ~TRUE~ if and only if *both* sides of the operator are ~TRUE~

- Example: guess the outcome first
  #+name: &&_op_true
  #+begin_src C :exports both
    if ( 3 > 1 && 5 == 10 )
      printf("The expression is TRUE.\n");
     else
       printf("The expression is FALSE.\n");
  #+end_src

  #+RESULTS: &&_op_true
  : The expression is FALSE.

- Example: guess the outcome first
  #+name: &&_op_false
  #+begin_src C :exports both
    if (3 < 5 && 5 == 5 )
      printf("The expression is TRUE.\n");
     else
       printf
         ("The expression is FALSE.\n");
  #+end_src

  #+RESULTS: &&_op_false
  : The expression is TRUE.

* || operator (logical OR)

- Evaluates a Boolean expression from left to right

- It is ~FALSE~ if and only *both* sides of the operator are ~FALSE~

- It is ~TRUE~ if either side of the operator is ~TRUE~

- Example: guess the outcome first
  #+name: ||_op_true
  #+begin_src C :exports both
    if ( 3 > 5 || 5 == 5 )
      printf("The expression is TRUE.\n");
     else
       printf("The expression is FALSE.\n");
  #+end_src

  #+RESULTS: ||_op_true
  : The expression is TRUE.

- Example: guess the outcome first
  #+name: ||_op_false
  #+begin_src C :exports both
    if ( 3 > 5 || 6 < 5 )
      printf("The expression is TRUE.\n");
     else
       printf("The expression is FALSE.\n");
  #+end_src

  #+RESULTS: ||_op_false
  : The expression is FALSE.

* PRACTICE Logical operators

- Go to Google Cloud shell (ide.cloud.google.com) and run the
  following command on the shell (~-O~ is a big-Oh, not a zero):
  #+begin_example
  wget -O logical.c tinyurl.com/logical-output
  #+end_example

- Open the file ~logical.c~ in the ~nano~ editor.

- Complete the ~printf~ statements for ~...~ in each of the code blocks
  according to the comments, and guess the output (0 or 1) by
  replacing the XX with your answer.

- Compile and run the program to see if you were right.

- Code template:
  #+begin_src C :tangle ../src/logical_template.c
    /***********************************************
     ,* logical.c: Write and predict logical results *
     ,* Input: None. Output: integer values          *
     ,* Author: Marcus Birkenkrahe GPLv3             *
     ,* Date: 02/24/2025                             *
     ,***********************************************/
    #include <stdio.h>

    int main(void)
    {
      // variable declarations
      int i, j, k;

      // TRANSLATE THE SENTENCE IN THE COMMENT INTO A LOGICAL EXPRESSION
      // AND PUT THE CODE WHERE THE ... ARE. GUESS THE VALUE OF THE
      // LOGICAL EXPRESSION AND REPLACE THE ? WITH IT.
      // EXAMPLE: Check if i is smaller than j => `i < j`
      // FOR i = 10 and j = 5: 10 < 5 is TRUE: ? => 1

      // Check if `(NOT i)` is smaller than j
      i = 10, j = 5;
      printf("%d = %d\n", ..., ?);

      // Check the value of `NOT(NOT (i)) + NOT(j)`
      i = 2, j = 1;
      printf("%d = %d\n", ..., ?);

      // Check if this is true: `NOT(x + y) = NOT(x) + NOT(y)`
      i = 2, j = 1;
      printf("%d = %d\n", ..., ?);

      // Compute `i AND j OR k`
      i = 5, j = 0, k = -5;
      printf("%d = %d\n", ..., ?);

      // Compute `i smaller than j OR k`
      i = 1, j = 2, k = 3;
      printf("%d = %d\n", ..., ?);

      return 0;
    }
  #+end_src

** Solution

#+begin_src C :tangle ../src/logical_solution.c
  /***********************************************
   ,* logical.c: Write and predict logical results *
   ,* Input: None. Output: integer values          *
   ,* Author: Marcus Birkenkrahe GPLv3             *
   ,* Date: 02/24/2025                             *
   ,***********************************************/
  #include <stdio.h>

  int main(void)
  {
    // variable declarations
    int i, j, k;

    // TRANSLATE THE SENTENCE IN THE COMMENT INTO A LOGICAL EXPRESSION
    // AND PUT THE CODE WHERE THE ... ARE. GUESS THE VALUE OF THE
    // LOGICAL EXPRESSION AND REPLACE THE ? WITH IT.
    // EXAMPLE: Check if i is smaller than j => `i < j`
    // FOR i = 10 and j = 5: 10 < 5 is TRUE: ? => 1

    // Check if `(NOT i)` is smaller than j, for i=10 and j=5
    i = 10, j = 5;
    printf("%d = %d\n", !i < j, 1); // !10 is 0, and 5 > 0 is TRUE (1)

    // Check the value of `NOT(NOT (i)) + NOT(j)`, for i=2 and j=1
    i = 2, j = 1;
    printf("%d = %d\n", !!i + !j, 1); // !!2 = !0 = 1, !1 = 0, 1 + 0 = 1

    // Check if this is true: `NOT(x + y) = NOT(x) + NOT(y)`
    i = 2, j = 1;
    printf("%d = %d\n", !(i+j)==!i+!j, 1); // !(2+1)=0 == !2+!1 = 0

    // Compute `i AND j OR k`, for i=5, j=0, k=-5
    i = 5, j = 0, k = -5;
    printf("%d = %d\n", i && j || k, 1); // 5 && 0 = 0, 0 || -5 = 0||1 = 1

    // Compute `i < j OR k`, for i=1, j=2, k=3
    i = 1, j = 2, k = 3;
    printf("%d = %d\n",  i < j || k, 1); // (i < j) = 1, 3 is TRUE, 1 || 1 is 1

    return 0;
  }
#+end_src

#+RESULTS:
: 1 = 1
: 1 = 1
: 1 = 1
: 1 = 1
: 1 = 1

* Proving Boolean equivalence with code

- Problem: show that ~p XOR q~ and ~(p AND NOT q) OR (NOT p AND q)~ are
  equivalent.

- Pseudocode:
  #+begin_example
  ALGORITHM: compute the expressions:
             A. (p XOR q)
             B. ((p AND NOT q) OR (NOT p AND q))
  Input: all truth values of p and q (stored in a file)
         |p0=0|q0=0|
         |p0=0|q0=1|
         |p0=1|q0=0|
         |p0=1|q0=1|
  Output: evaluation of A and B

  Begin:
     // Declare values to Boolean variables

     // Read in values from input file

     // Print A = p XOR q for all values of p and q

     // Print B = (p AND NOT q) OR (NOT p AND q) for all values of p and q
  End
  #+end_example

- Create the input file ~demorgan~ (or generate it manually on Windoze):
  #+begin_src bash
    echo "0 0" >  demorgan
    echo "0 1" >> demorgan
    echo "1 0" >> demorgan
    echo "1 1" >> demorgan
    cat demorgan
  #+end_src

  #+RESULTS:
  | 0 | 0 |
  | 0 | 1 |
  | 1 | 0 |
  | 1 | 1 |

- C code (without loops or arrays)
  #+begin_src C :cmdline < demorgan :main yes :includes <stdio.h> :results output :exports both :noweb yes
    // Declare Boolean variables
    int p0,p1,p2,p3,q0,q1,q2,q3;

    // Read in values from input file
    scanf("%d%d%d%d%d%d%d%d",&p0,&q0,&p1,&q1,&p2,&q2,&p3,&q3);

    // Check that input was correctly read
    printf("%d%d\n%d%d\n%d%d\n%d%d\n",p0,q0,p1,q1,p2,q2,p3,q3);

    // Print A = p XOR q for all values of p and q
    printf("p XOR q: %d %d %d %d\n",0,1,1,0);

    // Print B = (p AND NOT q) OR (NOT p AND q) for all values of p and q
    printf("p = %d, q = %d,(p AND !q) OR (!p AND q) = %-2d\n",p0,q0,(p0 && !q0) || (!p0 && q0));
    printf("p = %d, q = %d,(p AND !q) OR (!p AND q) = %-2d\n",p1,q1,(p1 && !q1) || (!p1 && q1));
    printf("p = %d, q = %d,(p AND !q) OR (!p AND q) = %-2d\n",p2,q2,(p2 && !q2) || (!p2 && q2));
    printf("p = %d, q = %d,(p AND !q) OR (!p AND q) = %-2d\n",p3,q3,(p3 && !q3) || (!p3 && q3));

    printf("\n.........Q.E.D.\n");
  #+end_src

  #+RESULTS:
  #+begin_example
  00
  01
  10
  11
  p XOR q: 0 1 1 0
  p = 0, q = 0,(p AND !q) OR (!p AND q) = 0
  p = 0, q = 1,(p AND !q) OR (!p AND q) = 1
  p = 1, q = 0,(p AND !q) OR (!p AND q) = 1
  p = 1, q = 1,(p AND !q) OR (!p AND q) = 0

  .........Q.E.D.
  #+end_example

- You could also dispense with reading the values (since they're
  constant) and set the values in the code - this makes it shorter:
  #+begin_src C :main yes :includes <stdio.h> :results output :exports both
    // Declare and assign values to Boolean variables
    int p0=0,q0=0,p1=0,q1=1,p2=1,q2=0,p3=1,q3=1;

    // Print A = p XOR q for all values of p and q
    printf("%d %d %d %d\n",0,1,1,0);

    // Print B = (p AND NOT q) OR (NOT p AND q) for all values of p and q
    printf("%-2d",(p0 && !q0) || (!p0 && q0));
    printf("%-2d",(p1 && !q1) || (!p1 && q1));
    printf("%-2d",(p2 && !q2) || (!p2 && q2));
    printf("%-2d",(p3 && !q3) || (!p3 && q3));

    printf("\n.........Q.E.D.\n");
  #+end_src

  #+RESULTS:
  : 0 1 1 0
  : 0 1 1 0
  : .........Q.E.D.

* Checking for upper and lower case

- Characters are represented by ASCII[fn:6] character sets

- E.g. ~a~ and ~A~ are represented by the ASCII codes 97 and 65,
  resp.

- Let's check that.
  #+name: ascii_input
  #+begin_src bash :results output
    echo "a A" > ascii
    cat ascii
  #+end_src

  #+RESULTS: ascii_input
  : a A

  In [[ascii]], two characters are scanned and then printed as characters
  and as integers:
  #+name: ascii
  #+begin_src C :cmdline < ascii :results output :export both
    char c1, c2;
    scanf("%c %c", &c1, &c2);
    printf("The ASCII value of %c is %d\n", c1, c1);
    printf("The ASCII value of %c is %d\n", c2, c2);
  #+end_src

  #+RESULTS: ascii
  : The ASCII value of a is 97
  : The ASCII value of A is 65

- What happens if you use the format specifier ~%c%c~ for =scanf=? Try it.
  #+begin_quote
  Answer: Instead of the ASCII value for 'A' you get the ASCII value
  for the space, because after picking up the ~a~, =scanf= finds the space
  (it only expects a string literal, and the space is one of those).
  #+end_quote

- User-friendly programs should use compound conditions to check for
  both lower and upper case letters:
  #+name: ascii_both
  #+begin_example C
  if (response == 'A' || response == 'a') // accept if either a or A is response
  #+end_example

* PRACTICE Checking for upper and lower case

1) Get the file ~letter.c~ from the command-line and open it in ~nano~:
   #+begin_src bash :results output
     wget -O letter.c tinyurl.com/letter-template
   #+end_src

2) ~letter.c~ accepts a character =letter= as input, checks whether the
   letter is =b= or not, and prints a corresponding message:
   #+begin_src C :cmdline < input :tangle ../src/letter-template.c
     /****************************************
      ,* letter.c: check character input       *
      ,* Input: two character values           *
      ,* Output: Input is 'b' or not 'b'       *
      ,* Author: Marcus Birkenkrahe GPLv3      *
      ,* Date: 02/27/2025                      *
      ,****************************************/
     #include <stdio.h>

     int main(void)
     {
       // TODO: declare character variables c1 and c2
       char letter;
       // TODO: get two characters c1 and c2 from the keyboard
       scanf("%c", &letter);
       // TODO: check whether `letter` is the same as `b`
       if (letter == 'b')
         printf("Input is 'b'.\n");
       else
         printf("Input is NOT 'b'.\n");

       return 0;
     }
   #+end_src

3) Compile the file, rename the object file to =letter=, and run it with
   different letters to check if it works.
   #+begin_example sh
   gcc letter.c -o letter
   ./letter
   #+end_example

4) Copy the file =letter.c= to a file =letter2.c= and open it:
   #+begin_example sh
   cp -v letter.c letter2.c
   #+end_example

5) Change the *condition* from checking only for equality with
   lower-case =b= to checking for equality with lower- or upper-case:
   #+begin_src C :cmdline < input :tangle letter2.c
     /****************************************
      ,* letter2c: check character input       *
      ,* Input: two character values           *
      ,* Output: Input is 'b' or 'B'           *
      ,* Author: Marcus Birkenkrahe GPLv3      *
      ,* Date: 02/27/2025                      *
      ,****************************************/

     #include <stdio.h>

     int main(void)
     {
       char letter;
       scanf("%c", &letter);

       if (letter == 'b' || letter == 'B')
         printf("Input is 'b' or 'B'.\n");
       else
         printf("Input is NOT 'b' or 'B'.\n");

       return 0;
     }
   #+end_src

6) Once more, compile =letter2.c=, rename the object file to =letter2=,
   and run it for different character input values to check it.

* PRACTICE ASCII code of letters

1) Create a file =ascii.c=

2) Get two letters =c1= and =c2= from the keyboard.

3) Print the letters both as characters, and as ASCII values.

4) Sample input and output:
   #+begin_example
   Input: b B

   Output:
   The ASCII value of b is 98.
   The ASCII value of B is 66.
   #+end_example

** *Solution:*
#+begin_src C :main no :includes :cmdline < input :tangle ascii.c
  /************************************************
   ,* ascii.c: print ASCII value of characters      *
   ,* Input: two character values                   *
   ,* Output: ASCII value (int) of character (char) *
   ,* Author: Marcus Birkenkrahe GPLv3              *
   ,* Date: 02/27/2025                              *
   ,************************************************/
  #include <stdio.h>

  int main(void)
  {
    char c1, c2;
    scanf("%c %c", &c1, &c2);

    printf("The ASCII value of %c is %d.\n", c1, c1);
    printf("The ASCII value of %c is %d.\n", c2, c2);
    return 0;
  }
#+end_src

#+RESULTS:
: The ASCII value of b is 98.
: The ASCII value of B is 66.

- Testing:
#+begin_src bash :results output :exports both
  gcc ascii.c -o ascii
  ./ascii < input
#+end_src

#+RESULTS:
: The ASCII value of b is 98.
: The ASCII value of B is 66.

- Input file:
  #+begin_src bash :results output :exports both
    echo "b B" > input
    cat input
  #+end_src

  #+RESULTS:
  : b B

* Checking for a range of values

- To validate input, you often need to check a range of values

- This is a common use of compound conditions, logical and
  relational operators

- We first create an input file ~num~ with a number in it.
  #+name: valid_input
  #+begin_src bash :results output
    echo 11 > num
    cat num
  #+end_src

  #+RESULTS: valid_input
  : 11

- What does the code below do? Will it run? What will the output be
  for our choice of input?
  #+name: validate
  #+begin_src C :cmdline < num :exports both

    int response = 0; // declare and initialize integer

    scanf("%d", &response);  // scan integer input

    // check if input was in range or not
    if ( response < 1 || response > 10 ) {
      puts("Number not in range.");
     } else {
      puts("Number in range.");
     }
  #+end_src

  #+RESULTS: validate
  : Number not in range.

- How can you translate a range like ~![1,10]~ into a conditional
  expression? It means that we want to test if a number is outside of
  the closed interval ~[1,10]~.

- The numbers that fulfil this condition are smaller than 1 or greater
  than 10, hence the condition is ~x < 1 || x > 10~.

- This is more conveniently written as ~x < 1 || 10 < x~.

* PRACTICE Checking for a range of values

1) Get the template for ~range.c~ from the command-line:
   #+begin_src bash :results output :exports both
     wget -O range.c tinyurl.com/range-template
   #+end_src

2) Define three integer variables =i=, =m=, and =n=, get their values from
   the keyboard, and check if the input value for =i= is in the interval
   =[m,n)=.

2) Complete, compile and run the file:
   #+begin_src C :main no :includes :tangle range.c :cmdline < input
     // range.c: compute condition with range
     // input: none. output: Boolean
     // author: Marcus Birkenkrahe GPLv3
     // date: 2/27/25
     #include <stdio.h>

     int main(void)
     {
       int i, m, n;
       scanf("%d %d %d", &i, &m, &n);

       if (m <= i && i < n)
         printf("%d is in the interval [%d,%d).\n", i, m, n);
       else
         printf("%d is NOT in the interval [%d,%d).\n", i, m, n);

       return 0;
     }
   #+end_src

   #+RESULTS:
   : 11 is NOT in the interval [0,10).

3) Compile =range.c=, rename the object file =range=, and run it with the
   sample values: 5, 0, 10 for i, m, n - testing if 5 is in [0,10).

4) Run =range= for different input values:

   | i = -5 | m = 0 | n = 10 |
   | i = 11 | m = 0 | n = 10 |
   | i = 0  | m = 0 | n = 10 |
   | i = 10 | m = 0 | n = 10 |

5) How would you change the condition to check if the input variable =i=
   is outside of [m,n) ?

** Solution:
#+begin_src C :main no :includes :tangle range.c :cmdline < input
  // range.c: compute condition with range
  // input: none. output: Boolean
  // author: Marcus Birkenkrahe GPLv3
  // date: 2/27/25
  #include <stdio.h>

  int main(void)
  {
    int i, m, n;
    scanf("%d %d %d", &i, &m, &n);

    if (i < m || n <= i)
      printf("%d is NOT in the interval [%d,%d).\n", i, m, n);
    else
      printf("%d is in the interval [%d,%d).\n", i, m, n);

    return 0;
  }
#+end_src

#+RESULTS:
: 5 is in the interval [0,10).

-----
Testing:
#+begin_src bash :results output :exports both
  echo "5 0 10" > input
  cat input
#+end_src

#+RESULTS:
: 5 0 10

* PRACTICE Chained expression

In C, the expression =i < j < k= is perfectly legal but it does NOT
check if =j= is between =i= and =k=, =i= \in =(i,k)=.

The relational operator =<= is evaluated from the left: =i < j= is
computed. It is either =1= (=TRUE=) or =0= (=FALSE=).

Next, =0 < k= or =1 < k= is checked.

1) Get the template for ~chain.c~ from the command-line:
   #+begin_src bash :results output :exports both
     wget -O chain.c tinyurl.com/chain-template
   #+end_src

2) Complete, compile and run the file:
   #+begin_src C :main no :includes
     // chain.c: compute condition
     // input: none. output: Boolean
     // author: Marcus Birkenkrahe GPLv3
     // date: 2/27/25
     #include <stdio.h>

     int main(void)
     {
       int i = 5, j = 1, k = 100;

       if (i < j < k)
         printf("TRUE: %d < %d < %d\n", i, j, k);
       else
         printf("NOT TRUE: %d < %d < %d\n", i, j, k);

       return 0;
     }
   #+end_src

   #+RESULTS:
   : TRUE: 5 < 1 < 100

3) Fix the code so that the output is correct. Then test it for
   different values of =i=, =j=, =k=.

** Solution:
#+begin_src C :main no :includes :includes :tangle chain.c :cmdline < input
  // chain.c: compute condition
  // input: none. output: Boolean
  // author: Marcus Birkenkrahe GPLv3
  // date: 2/27/25
  #include <stdio.h>

  int main(void)
  {
    int i = 5, j = 1, k = 100;

    if (i < j && j < k)
      printf("TRUE: %d < %d < %d\n", i, j, k);
    else
      printf("NOT TRUE: %d < %d < %d\n", i, j, k);

    return 0;
  }
#+end_src

#+RESULTS:
: NOT TRUE: 5 < 1 < 100

Testing:
#+begin_src bash :results output :exports both
  gcc chain.c -o chain
  ./chain
#+end_src

#+RESULTS:
: NOT TRUE: 5 < 1 < 100

With input:
#+begin_src C :main no :includes :includes :tangle chain.c :cmdline < input
  #include <stdio.h>

  int main(void)
  {
    int i,j,k;
    scanf("%d %d %d",&i,&j,&k);

    if (i < j && j < k)
      printf("TRUE: %d < %d < %d\n", i, j, k);
    else
      printf("NOT TRUE: %d < %d < %d\n", i, j, k);

    return 0;
  }
#+end_src

#+RESULTS:
: NOT TRUE: 1 < 5 < -100

Input file:
#+begin_src bash :results output :exports both
  echo "1 5 -100" > input
  cat input
#+end_src

#+RESULTS:
: 1 5 -100

* PRACTICE Upload your practice files as a ZIP archive

- ZIP your seven files on the command line as an archive file
  ~operators.zip~ and upload it to Canvas.

- On the shell:
  #+begin_example
  zip operators.zip calc.c predict.c boolean.c logical.c letter.c range.c chain.c
  #+end_example

- If you enter ~less operators.zip~ you will see your files in the
  archive (leave the ~less~ screen by typing =q=:
  #+attr_html: :width 600px:
  [[../img/zip.png]]

- If you enter ~file operators.zip~, you should see a message confirming
  that this is =Zip archive data=.
  #+begin_example
  $ file operators.zip
  operators.zip: Zip archive data, at least v1.0 to extract, compression method=store
  #+end_example

* References

- Davenport/Vine (2015) C Programming for the Absolute Beginner
  (3ed). Cengage Learning.
- <<logic>> GVSUmath (Aug 10, 2012). Proving Logical Equivalences
  without Truth Tables [video]. [[https://youtu.be/iPbLzl2kMHA][URL: youtu.be/iPbLzl2kMHA]].
- Kernighan/Ritchie (1978). The C Programming Language
  (1st). Prentice Hall.
- King (2008). C Programming - A modern approach (2e). W A Norton.
- Orgmode.org (n.d.). 16 Working with Source Code [website]. [[https://orgmode.org/manual/Working-with-Source-Code.html][URL:  orgmode.org]]

* Footnotes

[fn:1] [[https://www.programiz.com/c-programming/library-function/math.h/pow][See here for more information]].

[fn:2]Only from R version 4.1 - before that, you have to use the
magrittr pipe operator ~%>%~.

[fn:3]Algebra is a branch of mathematics that deals with *symbols* and
the *rules* for combining them to express *relationships* and solve
*equations*.

[fn:4] *Logic Gates* represent Boolean expressions through digital
circuits - the basis of computers. *Set theory* interprets Boolean
operations as union, intersection, and complement. *Venn diagrams*
visualize Boolean operations using overlapping circles. *Binary
arithmetic* uses Boolean values 0 and 1 in computational operations =
truth tables.

[fn:5]These operators were inherited from Ken Thompson's earlier B
language. They are not faster just shorter and more convenient.

[fn:6] ASCII stands for the [[https://en.wikipedia.org/wiki/ASCII][American Standard Code for Information
Interchange]].
