#+title: Notes (Development)
#+author: Marcus Birkenkrahe
#+subtitle: CSC 100
#+SEQ_TODO: PRACTICE | DONE
#+STARTUP: overview hideblocks indent entitiespretty
#+OPTIONS: toc:1 num:1 ^:nil
#+PROPERTY: :header-args:C       :main yes :includes <stdio.h> <stdlib.h> <time.h> :noweb yes :results output :exports both
#+PROPERTY: :header-args:python  :session *Python* :python python3 :results output :exports both
#+PROPERTY: :header-args:R       :session *R* :results graphics output file :exports both
#+PROPERTY: :header-args:C++     :main yes :includes <iostream> :results output :exports both
* TO DO START OF TERM

- Print practice exercises
- Print scripts for orientation, introduction

* IN PROGRESS Workload computation

- Different versions:
  1) All in one file including initialization.
  2) All in one file but initialized from command-line.
  3) Modularized using functions, initialized from command-line.

- Version 1: All in one file
#+begin_src C :results output
  // declare and define variables given: no of weeks, classes,
  // assignments, tests, class length
  int number_of_weeks = 16,
    classes_per_week = 3,
    number_of_coding_assignments = 14,
    number_of_tests = 14;
  float hrs_per_class = 1.f;

  // variables estimated: hrs per test and assignment
  float hrs_per_test = 1.f;
  float hrs_per_coding_assignment = 2.f;

  // computed:
  float hrs_in_class,
    hrs_test,
    hrs_coding_assignment,    
    hrs_per_week,
    hrs_total;

  // compute results
  hrs_in_class =
    number_of_weeks * classes_per_week * hrs_per_class;
  hrs_test =
    number_of_tests * hrs_per_test;
  hrs_coding_assignment =
    number_of_coding_assignments * hrs_per_coding_assignment;
  hrs_total =
    hrs_in_class +
    hrs_coding_assignment +
    hrs_test;
  // print results
  printf("Time in class: %g hrs.\n", hrs_in_class);
  printf("Time outside of class: %g hrs.\n",
         hrs_total - hrs_in_class);
  printf("Time for tests [%g hrs/test]: %g hrs.\n",hrs_per_test,hrs_test);
  printf("Time for coding assignments [%g hrs/pgm]: %g hrs.\n",hrs_per_coding_assignment,hrs_coding_assignment);
    printf("Total number of hrs in term: %g.\n", hrs_total);
  printf("Weekly workload (outside of class): %g (%g)\n",
         hrs_total/number_of_weeks, (hrs_total-hrs_in_class)/number_of_weeks);
#+end_src

#+RESULTS:
: Time in class: 48 hrs.
: Time outside of class: 42 hrs.
: Time for tests [1 hrs/test]: 14 hrs.
: Time for coding assignments [2 hrs/pgm]: 28 hrs.
: Total number of hrs in term: 90.
: Weekly workload (outside of class): 5.625 (2.625)

* Group Presentation Topics for Introductory C Programming

1. *The Structure of a C Program*
   - Explain the key components of a C program (e.g., `#include`, `main()`, statements, and comments).
   - Demonstrate a simple program and explain its structure.

2. *Data Types and Variables in C*
   - Discuss primitive data types (`int`, `float`, `char`, etc.).
   - Explain variable declarations and initialization.
   - Include a demonstration of operations on variables.

3. *Control Flow Statements*
   - Explain `if`, `else`, and `switch` statements.
   - Demonstrate conditional logic with examples.
   - Include real-world scenarios (e.g., simple menu systems).

4. *Loops in C*
   - Discuss the use of `for`, `while`, and `do-while` loops.
   - Compare the loops and explain when to use each.
   - Demonstrate a program that uses loops (e.g., calculating the factorial of a number).

5. *Functions in C*
   - Explain the purpose and structure of functions.
   - Discuss function declarations, definitions, and calls.
   - Demonstrate a program that uses reusable functions (e.g., a program with a `sum()` function).

6. *Arrays in C*
   - Explain how arrays store data.
   - Discuss one-dimensional and two-dimensional arrays.
   - Demonstrate a program that uses arrays for simple data processing (e.g., summing elements).

7. *Strings in C*
   - Explain how strings are handled in C (as character arrays).
   - Discuss common functions like `strlen`, `strcpy`, and `strcmp`.
   - Demonstrate a program that manipulates strings (e.g., checking if a string is a palindrome).

8. *Pointers in C* (Simplified for Beginners)
   - Introduce pointers and their role in C programming.
   - Discuss pointer syntax and basic usage (e.g., accessing variables via pointers).
   - Demonstrate a simple pointer-based program.

9. *File Input and Output*
   - Explain how to open, read, write, and close files in C.
   - Discuss common functions like `fopen`, `fscanf`, and `fprintf`.
   - Demonstrate a program that writes data to a file and reads it back.

10. *Debugging and Error Handling in C*
    - Explain common errors in C (e.g., syntax errors, segmentation faults).
    - Discuss techniques for debugging (e.g., using `printf` for tracing).
    - Demonstrate fixing a buggy program.

11. *Preprocessor Directives*
    - Explain the role of preprocessor directives like `#include`, `#define`, and conditional compilation.
    - Show a program that uses macros or conditional compilation.

12. *Memory Management Basics*
    - Discuss how memory is allocated in C (`malloc`, `calloc`, `free`).
    - Introduce the stack and heap (conceptually).
    - Demonstrate a simple program that uses dynamic memory allocation.

13. *The Compilation Process*
    - Explain how a C program goes from source code to an executable file.
    - Discuss the stages: preprocessing, compilation, linking, and execution.
    - Include a live demonstration using `gcc`.

14. *Using Libraries in C*
    - Explain how libraries work in C (e.g., the standard library).
    - Demonstrate using functions from `math.h` or `stdlib.h`.
    - Include a program that performs a mathematical operation using a library function.

15. *Working with Command-Line Arguments*
    - Explain `argc` and `argv` in `main()`.
    - Discuss how command-line arguments are passed to a program.
    - Demonstrate a program that processes user input via command-line arguments.

* Grades graphs

- Test 1
  #+begin_src R :file ../img/test1.png :session *R* :results file graphics output :exports both
    ## Variables
    t1 <- c(15,18,18,24,25,26,rep(27,3),rep(28,4),rep(29,5),rep(30,6))
    t1_normal <- t1/30 * 100
    t1_mean = mean(t1_normal)
    t1_mean_fmt <- as.numeric(format(t1_mean,digits=4))
    ## Plot
    hist(t1_normal,
         main="CSC 100: Test 1 (N=24)",
         xlab="Percentage",
         ylab="Number of participants",
         col="mistyrose")
    abline(v=mean(t1_mean),lwd=3,col="red")
    ## Legend
    legend("top",
           legend=paste("Average:",t1_mean_fmt,"%"),
           lty=1,lwd=3,
           col="red")
    #+end_src

    #+RESULTS:
    [[file:../img/test1.png]]
    
- Programming assignment results close to midterm:
  #+begin_src R :file ../img/grade1.png :session *R* :results file graphics output :exports both
    ## Variables
    assignments <- c(0,22.5,22.5,55,48.75,53.75,71.25,78.75,80, 87.5, 80,
                     86.25,78.75,88.75,93.75,86.25,92.5,95,88.75,88.75,
                     92.5,97.5, 93.33, 93.75, 96.25, 96.25, 98.75, 98.75,
                     100)
    assignments_mean = mean(assignments)
    assignments_mean_fmt <- as.numeric(format(assignments_mean,digits=4))
    ## Plot
    library(MASS)
    truehist(assignments,
         xlab="Percentage",
         ylab="Number of participants",
         col="steelblue")
    abline(v=assignments_mean_fmt,lwd=3,col="blue")
    ## Legend
    legend("topleft",
           legend=paste("Average:",assignments_mean_fmt,"%"),
           lty=1,lwd=3,
           col="blue")
    title(paste("CSC 100: Assignments 1-4 (N =", length(assignments), ") - Feb 22, 2025"))
  #+end_src

  #+RESULTS:
  [[file:../img/grade1.png]]

- Density plots:
  #+begin_src R :file ../img/grade2.png :session *R* :results file graphics output :exports both
    ## Variables
    assignments <- c(0,22.5,22.5,55,48.75,53.75,71.25,78.75,80, 87.5, 80,
                     86.25,78.75,88.75,93.75,86.25,92.5,95,88.75,88.75,
                     92.5,97.5, 93.33, 93.75, 96.25, 96.25, 98.75, 98.75,
                     100)
    assignments_mean = mean(assignments)
    assignments_mean_fmt <- as.numeric(format(assignments_mean,digits=4))
    dens <- density(assignments)
    ## Plot
    plot(dens,
         main="",
         xlab="Percentage",
         ylab="Number of participants",
         col="steelblue",
         lwd=2)
    polygon(dens$x, dens$y, col=rgb(0.2, 0.2, 1, 0.5), border=NA)
    abline(v=assignments_mean_fmt,lwd=3,col="blue")
    ## Legend
    legend("top",
           legend=paste("Average:",assignments_mean_fmt,"%"),
           lty=1,lwd=3,
           col="blue")
    title(paste("CSC 100: Assignments 1-4 (N =", length(assignments), ") - Feb 23, 2025"))
    #+end_src

    #+RESULTS:
    [[file:../img/grade2.png]]

- Tests results so far:
  #+begin_src R :file ../img/grade3.png :session *R* :results file graphics output :exports both
    ## Variables 

    tests <- c(91.67,48.6,80,81.74,96,93.5,81.74,79.33,88,73.33,90,
               79.33,95.33,83.83,77.33,96.5,85, 80.67,96,98.26,94,84,
               95.65,99,94.67,94.67,89,92.67,96.67)

    tests_mean = mean(tests)
    tests_mean_fmt <- as.numeric(format(tests_mean,digits=4))
    dens <- density(tests)
    ## Plot
    plot(dens,
         main="",
         xlab="Percentage",
         ylab="Number of participants",
         col="red",
         lwd=2)
    polygon(dens$x, dens$y, col=rgb(1, 0.894, 1, 0.882), border=NA)
    abline(v=tests_mean_fmt,lwd=3,col="red")
    ## Legend
    legend("top",
           legend=paste("Average:",tests_mean_fmt,"%"),
           lty=1,lwd=3,
           col="red")
    title(paste("CSC 100: Tests 1-5 (N =", length(tests), ") - Feb 23, 2025"))
    #+end_src

    #+RESULTS:
    [[file:../img/grade3.png]]
* NOT ~!~ question by Nichole

#+begin_quote
Does the operator ! convert the value of the operand to a binary value
and then act to reverse that value?
#+end_quote
â€‹Yes, very good observation. Reverse = inverse.

#+begin_quote
If x=5, ! causes the machine to see the five as TRUE and returns the
 reverse of that, so !x will return FALSE because what the machine
 sees is NOT TRUE, i.e. !1?
#+end_quote

In C, all values except =0= are considered =TRUE= by the machine.
#+begin_src C :results output
  float truth[]={0,1,-100,3.14};

  for (int i=0; i<4;i++) {
    if(truth[i])
      printf("%g is TRUE\n",truth[i]);
    else 
      printf("%g is FALSE\n",truth[i]);
   }
#+end_src

#+RESULTS:
: 0 is FALSE
: 1 is TRUE
: -100 is TRUE
: 3.14 is TRUE

For your example: the =stdbool= header file allows you to define a data
type =bool= but C still only uses 1 and 0 internally for TRUE and FALSE.
#+begin_src C
  #include <stdbool.h>
  bool x = 5;
  printf("%d %d",x, !x); // 5 is TRUE and !5 = 0 is FALSE
#+end_src

#+RESULTS:
: 1 0

#+begin_quote
And if x=0, ! causes the machine to see the zero as FALSE so the
machine will return TRUE because what it sees is NOT FALSE, i.e. !0?
#+end_quote

#+begin_src C
  #include <stdbool.h>
  bool x = 0;
  printf("%d %d",x, !x); // 5 is TRUE and !5 = 0 is FALSE
#+end_src

#+RESULTS:
: 0 1

